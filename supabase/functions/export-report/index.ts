import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { PDFDocument, rgb, StandardFonts } from "https://esm.sh/pdf-lib@1.17.1";
import { serveWithObservability } from "../_shared/observability.ts";

const APP_ORIGIN = Deno.env.get("APP_ORIGIN") ?? "*";
const corsHeaders = {
  "Access-Control-Allow-Origin": APP_ORIGIN,
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

interface ExportRequest {
  saccoId?: string;
  district?: string;
  start?: string;
  end?: string;
  format?: "csv" | "pdf";
  locale?: "en" | "rw" | "fr";
  limit?: number;
  separator?: "," | ";";
}

const parseDate = (value: string | undefined, fallback: Date) => {
  if (!value) return fallback;
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    return fallback;
  }
  return parsed;
};

const formatCurrency = (amount: number) =>
  new Intl.NumberFormat("rw-RW", {
    style: "currency",
    currency: "RWF",
    minimumFractionDigits: 0,
  }).format(amount);
const csvEscape = (value: string) => {
  if (value.includes(",") || value.includes('"') || value.includes("\n")) {
    return '"' + value.replace(/"/g, '""') + '"';
  }
  return value;
};

const toDateOnly = (value: Date) => value.toISOString().slice(0, 10);

serveWithObservability("export-report", async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const url = new URL(req.url);
    const queryParams: ExportRequest = {
      saccoId: url.searchParams.get("saccoId") ?? undefined,
      district: url.searchParams.get("district") ?? undefined,
      start: url.searchParams.get("start") ?? undefined,
      end: url.searchParams.get("end") ?? undefined,
      format: (url.searchParams.get("format") as "csv" | "pdf" | null) ?? "pdf",
    };

    let params: ExportRequest = { ...queryParams };

    if (req.method !== "GET") {
      const contentType = req.headers.get("content-type") ?? "";
      if (contentType.includes("application/json")) {
        const body = (await req.json().catch(() => null)) as Record<string, unknown> | null;
        if (body && typeof body === "object") {
          const readString = (value: unknown) =>
            typeof value === "string" && value.trim() ? value.trim() : undefined;
          const readFormat = (value: unknown): "csv" | "pdf" | undefined =>
            value === "csv" || value === "pdf" ? value : undefined;
          const readLocale = (value: unknown): "en" | "rw" | "fr" | undefined =>
            value === "en" || value === "rw" || value === "fr" ? value : undefined;
          const readSep = (value: unknown): "," | ";" | undefined =>
            value === "," || value === ";" ? value : undefined;
          const readInt = (value: unknown): number | undefined => {
            if (typeof value === "number" && Number.isFinite(value)) return Math.floor(value);
            if (typeof value === "string" && /^\d+$/.test(value)) return parseInt(value, 10);
            return undefined;
          };

          params = {
            saccoId: readString(body.saccoId) ?? params.saccoId ?? readString(body.sacco_id),
            district: readString(body.district) ?? params.district,
            start: readString(body.start) ?? readString(body.from) ?? params.start,
            end: readString(body.end) ?? readString(body.to) ?? params.end,
            format: readFormat(body.format) ?? params.format ?? "pdf",
            locale: readLocale(body.locale) ?? params.locale,
            separator: readSep(body.separator) ?? params.separator,
            limit: readInt(body.limit) ?? params.limit,
          };
        }
      }
    }

    params.format = params.format ?? "pdf";
    const locale = (params.locale ?? "en") as "en" | "rw" | "fr";

    const labels = {
      en: {
        header: (name?: string | null) => (name ? `${name} — Ibimina` : "Umurenge SACCO — Ibimina"),
        summary: "Reporting summary",
        period: "Period",
        totalPosted: "Total posted",
        dailyTotals: "Daily totals (last 14 days)",
        colIkimina: "Ikimina",
        colCode: "Code",
        colTxn: "Txn",
        colAmount: "Amount",
        colShare: "Share",
        grandTotal: "Grand total",
        generated: "Generated by SACCO+ on",
        csvHeader: "Ikimina,Code,Transactions,Amount,Share",
        csvTotal: "Total",
      },
      rw: {
        header: (name?: string | null) => (name ? `${name} — Ibimina` : "Umurenge SACCO — Ibimina"),
        summary: "Incamake ya raporo",
        period: "Igihe",
        totalPosted: "Byanditswe byose",
        dailyTotals: "Umunsi ku munsi (iminsi 14 ishize)",
        colIkimina: "Ikimina",
        colCode: "Code",
        colTxn: "Trans.",
        colAmount: "Amafaranga",
        colShare: "Igice",
        grandTotal: "Igiteranyo",
        generated: "Byakozwe na SACCO+ ku",
        csvHeader: "Ikimina,Code,Transakisi,Amafaranga,Igice",
        csvTotal: "Igiteranyo",
      },
      fr: {
        header: (name?: string | null) => (name ? `${name} — Ibimina` : "Umurenge SACCO — Ibimina"),
        summary: "Résumé du rapport",
        period: "Période",
        totalPosted: "Total validé",
        dailyTotals: "Totaux quotidiens (14 derniers jours)",
        colIkimina: "Ikimina",
        colCode: "Code",
        colTxn: "Txns",
        colAmount: "Montant",
        colShare: "Part",
        grandTotal: "Total général",
        generated: "Généré par SACCO+ le",
        csvHeader: "Ikimina,Code,Transactions,Montant,Part",
        csvTotal: "Total",
      },
    } as const;

    const numberLocale = locale === "en" ? "en-RW" : locale === "fr" ? "fr-RW" : "rw-RW";
    const formatCurrency = (amount: number) =>
      new Intl.NumberFormat(numberLocale, {
        style: "currency",
        currency: "RWF",
        minimumFractionDigits: 0,
      }).format(amount);
    const sep = (params.separator ?? ",") as "," | ";";

    const supabaseUrl = Deno.env.get("SUPABASE_URL");
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    if (!supabaseUrl || !supabaseKey) {
      throw new Error("Missing Supabase credentials");
    }

    const supabase = createClient(supabaseUrl, supabaseKey);

    const start = parseDate(params.start, new Date(Date.now() - 30 * 24 * 60 * 60 * 1000));
    const end = parseDate(params.end, new Date());

    let saccoIds: string[] | undefined;

    if (params.saccoId) {
      saccoIds = [params.saccoId];
    } else if (params.district) {
      const { data: saccoRows } = await supabase
        .schema("app")
        .from("saccos")
        .select("id")
        .eq("district", params.district);
      saccoIds = (saccoRows ?? []).map((row) => row.id as string);
    }

    let paymentsQuery = supabase
      .schema("app")
      .from("payments")
      .select("id, sacco_id, ikimina_id, amount, occurred_at, status")
      .gte("occurred_at", start.toISOString())
      .lte("occurred_at", end.toISOString());

    if (saccoIds?.length) {
      paymentsQuery = paymentsQuery.in("sacco_id", saccoIds);
    }

    const { data: payments, error: paymentsError } = await paymentsQuery;

    if (paymentsError) {
      throw paymentsError;
    }

    const { data: ibiminaRows } = await supabase
      .schema("app")
      .from("ikimina")
      .select("id, name, code, sacco_id");

    const totalsByIkimina = new Map<
      string,
      { name: string; code: string; amount: number; count: number }
    >();
    let grandTotal = 0;
    let totalCount = 0;

    for (const payment of payments ?? []) {
      if (!payment.ikimina_id || !["POSTED", "SETTLED"].includes(payment.status)) continue;
      const match = (ibiminaRows ?? []).find((row) => row.id === payment.ikimina_id);
      if (!match) continue;
      const current = totalsByIkimina.get(payment.ikimina_id) ?? {
        name: match.name,
        code: match.code,
        amount: 0,
        count: 0,
      };
      current.amount += payment.amount;
      current.count += 1;
      totalsByIkimina.set(payment.ikimina_id, current);
      grandTotal += payment.amount;
      totalCount += 1;
    }

    const sortedTotals = Array.from(totalsByIkimina.values()).sort((a, b) => b.amount - a.amount);
    const csvLimit = Math.max(
      1,
      Math.min(
        typeof params.limit === "number" ? Math.floor(params.limit) : Number.POSITIVE_INFINITY,
        100
      )
    );
    const limitedForCsv = Number.isFinite(csvLimit)
      ? sortedTotals.slice(0, csvLimit)
      : sortedTotals;

    // Build daily totals sparkline data (last 14 days within the requested period)
    const dailyMap = new Map<string, number>();
    for (const row of payments ?? []) {
      if (!["POSTED", "SETTLED"].includes(row.status)) continue;
      const day = (row.occurred_at as string).slice(0, 10);
      dailyMap.set(day, (dailyMap.get(day) ?? 0) + (row.amount as number));
    }
    const dailyTotals = Array.from(dailyMap.entries())
      .sort((a, b) => a[0].localeCompare(b[0]))
      .map(([date, amount]) => ({ date, amount }));
    const lastDays = dailyTotals.slice(-14);

    if (params.format === "csv") {
      let header = labels[locale].csvHeader;
      if (sep !== ",") header = header.replace(/,/g, sep);
      let csv = header + "\n";
      for (const row of limitedForCsv) {
        const share = grandTotal > 0 ? Math.round((row.amount / grandTotal) * 100) : 0;
        csv +=
          [
            csvEscape(row.name),
            csvEscape(row.code),
            String(row.count),
            String(row.amount),
            `${share}%`,
          ].join(sep) + "\n";
      }
      csv +=
        [labels[locale].csvTotal, "", String(totalCount), String(grandTotal), "100%"].join(sep) +
        "\n";

      return new Response(csv, {
        headers: {
          ...corsHeaders,
          "Content-Type": "text/csv",
          "Content-Disposition": `attachment; filename="ibimina-report-${toDateOnly(start)}-to-${toDateOnly(end)}${limitedForCsv.length < sortedTotals.length ? "-sample" : ""}.csv"`,
        },
      });
    }

    const pdf = await PDFDocument.create();
    const page = pdf.addPage([595.28, 841.89]);
    const font = await pdf.embedFont(StandardFonts.Helvetica);
    const bold = await pdf.embedFont(StandardFonts.HelveticaBold);
    const { height } = page.getSize();

    // Branding
    let titleColor = rgb(0, 0.63, 0.87);
    let saccoName: string | null = null;
    let logoBytes: Uint8Array | null = null;
    if (params.saccoId) {
      const { data: saccoRow } = await supabase
        .schema("app")
        .from("saccos")
        .select("name, logo_url, brand_color")
        .eq("id", params.saccoId)
        .single();
      if (saccoRow) {
        saccoName = (saccoRow as { name: string | null }).name ?? null;
        const brand = (saccoRow as { brand_color?: string | null }).brand_color ?? null;
        if (brand && /^#?[0-9a-fA-F]{6}$/.test(brand)) {
          const hex = brand.startsWith("#") ? brand.slice(1) : brand;
          const r = parseInt(hex.slice(0, 2), 16) / 255;
          const g = parseInt(hex.slice(2, 4), 16) / 255;
          const b = parseInt(hex.slice(4, 6), 16) / 255;
          titleColor = rgb(r, g, b);
        }
        const logoUrl = (saccoRow as { logo_url?: string | null }).logo_url ?? null;
        if (logoUrl) {
          try {
            const res = await fetch(logoUrl);
            if (res.ok) {
              const arr = new Uint8Array(await res.arrayBuffer());
              logoBytes = arr;
            }
          } catch (_) {
            // ignore logo fetch failures
          }
        }
      }
    }

    const headerTitle = labels[locale].header(saccoName);
    let cursorY = height - 72;
    // Helper to render header title with optional wrapping if too long
    const drawHeaderTitle = async (xStart: number) => {
      const maxWidth = 472 - (xStart - 48);
      const width = bold.widthOfTextAtSize(headerTitle, 20);
      if (width <= maxWidth) {
        page.drawText(headerTitle, {
          x: xStart,
          y: height - 72,
          size: 20,
          font: bold,
          color: titleColor,
        });
        return;
      }
      // Attempt to split at em dash into two lines
      const parts = headerTitle.split(" — ");
      if (parts.length === 2) {
        const [left, right] = parts;
        const line1 =
          bold.widthOfTextAtSize(left, 20) <= maxWidth
            ? left
            : left.slice(
                0,
                Math.max(1, Math.floor(left.length * (maxWidth / bold.widthOfTextAtSize(left, 20))))
              ) + "…";
        const line2 =
          bold.widthOfTextAtSize(`— ${right}`, 16) <= maxWidth
            ? `— ${right}`
            : "— " +
              right.slice(
                0,
                Math.max(
                  1,
                  Math.floor(right.length * (maxWidth / bold.widthOfTextAtSize(right, 16)))
                )
              ) +
              "…";
        page.drawText(line1, {
          x: xStart,
          y: height - 68,
          size: 20,
          font: bold,
          color: titleColor,
        });
        page.drawText(line2, {
          x: xStart,
          y: height - 88,
          size: 16,
          font: bold,
          color: titleColor,
        });
        cursorY = height - 106;
        return;
      }
      // Fallback truncate headerTitle
      const factor = maxWidth / width;
      const cut = Math.max(1, Math.floor(headerTitle.length * factor) - 1);
      page.drawText(headerTitle.slice(0, cut) + "…", {
        x: xStart,
        y: height - 72,
        size: 20,
        font: bold,
        color: titleColor,
      });
    };

    if (logoBytes) {
      try {
        const isPng = logoBytes[0] === 0x89 && logoBytes[1] === 0x50; // crude check
        const img = isPng ? await pdf.embedPng(logoBytes) : await pdf.embedJpg(logoBytes);
        const scaled = img.scale(60 / img.height);
        page.drawImage(img, {
          x: 48,
          y: height - 72 - scaled.height + 8,
          width: scaled.width,
          height: scaled.height,
        });
        await drawHeaderTitle(48 + scaled.width + 12);
      } catch {
        await drawHeaderTitle(48);
      }
    } else {
      await drawHeaderTitle(48);
    }
    // If wrapped, cursorY might be reduced
    const summaryY = Math.min(cursorY - 16, height - 96);
    page.drawText(labels[locale].summary, { x: 48, y: summaryY, size: 12, font });
    page.drawText(`${labels[locale].period}: ${toDateOnly(start)} → ${toDateOnly(end)}`, {
      x: 48,
      y: summaryY - 18,
      size: 10,
      font,
    });
    page.drawText(`${labels[locale].totalPosted}: ${formatCurrency(grandTotal)}`, {
      x: 48,
      y: summaryY - 36,
      size: 10,
      font,
    });

    cursorY = Math.min(summaryY - 40, height - 168);
    const rowHeight = 18;

    // Small sparkline chart (daily totals) above the table
    const chartTop = cursorY;
    if (lastDays.length > 0) {
      const chartHeight = 36;
      const chartWidth = 472;
      const chartX = 48;
      const maxVal = Math.max(...lastDays.map((d) => d.amount), 1);
      const barGap = 4;
      const barWidth = Math.max(
        6,
        Math.floor((chartWidth - barGap * (lastDays.length - 1)) / lastDays.length)
      );
      // Label
      page.drawText(labels[locale].dailyTotals, {
        x: chartX,
        y: cursorY,
        size: 10,
        font,
        color: rgb(0.35, 0.45, 0.5),
      });
      const baseY = cursorY - 10;
      // Adjust sparkline bar color for contrast if brand is too dark
      const luminance = (c: { r: number; g: number; b: number }) =>
        0.2126 * c.r + 0.7152 * c.g + 0.0722 * c.b;
      let barColor = titleColor;
      const t = {
        r: (titleColor as any).r ?? 0,
        g: (titleColor as any).g ?? 0,
        b: (titleColor as any).b ?? 0,
      };
      if (luminance(t) < 0.5) {
        const mix = (v: number) => Math.min(1, v * 0.5 + 0.5);
        barColor = rgb(mix(t.r), mix(t.g), mix(t.b));
      }
      let x = chartX;
      for (const d of lastDays) {
        const h = Math.max(2, Math.round((d.amount / maxVal) * chartHeight));
        page.drawRectangle({ x, y: baseY - h, width: barWidth, height: h, color: barColor });
        x += barWidth + barGap;
      }
      cursorY = baseY - chartHeight - 12;
    }

    // Table header and layout helpers
    const nameX = 48;
    const codeX = 240;
    const txnX = 310;
    const amtX = 360;
    const shareX = 460;
    const nameColWidth = codeX - nameX - 8;
    const codeColWidth = txnX - codeX - 8;

    // Utility to fit text into column with ellipsis
    const fitText = (text: string, maxWidth: number, fnt: typeof font, size = 10) => {
      let t = text ?? "";
      const widthOf = (s: string) => fnt.widthOfTextAtSize(s, size);
      if (widthOf(t) <= maxWidth) return t;
      const ell = "…";
      // binary shrink
      let lo = 0;
      let hi = t.length;
      let best = "";
      while (lo <= hi) {
        const mid = Math.floor((lo + hi) / 2);
        const candidate = t.slice(0, mid) + ell;
        if (widthOf(candidate) <= maxWidth) {
          best = candidate;
          lo = mid + 1;
        } else {
          hi = mid - 1;
        }
      }
      return best || ell;
    };

    page.drawText(labels[locale].colIkimina, { x: nameX, y: cursorY, size: 11, font: bold });
    page.drawText(labels[locale].colCode, { x: codeX, y: cursorY, size: 11, font: bold });
    page.drawText(labels[locale].colTxn, { x: txnX, y: cursorY, size: 11, font: bold });
    page.drawText(labels[locale].colAmount, { x: amtX, y: cursorY, size: 11, font: bold });
    page.drawText(labels[locale].colShare, { x: shareX, y: cursorY, size: 11, font: bold });
    cursorY -= rowHeight;

    for (const row of sortedTotals) {
      if (cursorY < 72) {
        page.drawText("…", { x: 48, y: cursorY, size: 11, font });
        break;
      }
      page.drawText(fitText(row.name, nameColWidth, font), {
        x: nameX,
        y: cursorY,
        size: 10,
        font,
      });
      page.drawText(fitText(row.code, codeColWidth, font), {
        x: codeX,
        y: cursorY,
        size: 10,
        font,
      });
      page.drawText(String(row.count ?? 0), { x: txnX, y: cursorY, size: 10, font });
      page.drawText(formatCurrency(row.amount), { x: amtX, y: cursorY, size: 10, font });
      const share = grandTotal > 0 ? Math.round((row.amount / grandTotal) * 100) : 0;
      page.drawText(`${share}%`, { x: shareX, y: cursorY, size: 10, font });
      cursorY -= rowHeight;
    }

    page.drawRectangle({
      x: 48,
      y: cursorY - 1,
      width: 472,
      height: 0.75,
      color: rgb(0.12, 0.25, 0.2),
    });
    cursorY -= rowHeight;
    page.drawText(`${labels[locale].grandTotal}: ${formatCurrency(grandTotal)}`, {
      x: 48,
      y: cursorY,
      size: 11,
      font: bold,
    });
    page.drawText(`Txn: ${totalCount}`, { x: 310, y: cursorY, size: 11, font: bold });

    // Footer
    page.drawText(`${labels[locale].generated} ${new Date().toISOString().slice(0, 10)}`, {
      x: 48,
      y: 48,
      size: 9,
      font,
      color: rgb(0.35, 0.45, 0.5),
    });

    const pdfBytes = await pdf.save();

    return new Response(pdfBytes, {
      headers: {
        ...corsHeaders,
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="ibimina-report-${toDateOnly(start)}-to-${toDateOnly(end)}.pdf"`,
      },
    });
  } catch (error) {
    console.error("Export report failed", error);
    const message = error instanceof Error ? error.message : "Unexpected error";
    return new Response(JSON.stringify({ error: message }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 400,
    });
  }
});
